[[面向对象-OOP]]
### Super关键字

`super`可以理解为父类的

`super`可以用来调用：属性方法构造器

`super` 关键字的使用 - 属性和方法

-   在子类的方法或构造器中使用 `super.属性` 或 `super.方法` 的方式，显式的调用父类中声明的属性和方法。但是通常情况下我们都习惯省略 `super`。 `super` 不能调用父类的 `private` 方法和属性
    
-   如果子父类定义了同名的属性方法构造器
    
    -   子类调用时优先调用自己定义的，因为`java`会优先在对象内部寻找有无符合条件（同名）的属性方法构造器，然后再去父类寻找。
        
    -   如果想要调用父类中声明的属性，则必须显式的使用 `super.`进行调用
        
-   如果子类没有重写父类的方法，那么使用 `this` 或者 `super` 调用都是父类定义的方法
    
    -   唯一的区别是写 `this` 是先在子类中寻找； `super` 是直接去父类中寻找
        
    -   注意：这里的父类包括但不仅限于子类的直接父类，其间接父类同样纳入考量
        

`super` 调用构造器

 public Person(String name,int age) {  
 this.name = name;  
 this.age = age;  
 }  
 public Student(String name,int age,String major) {  
// this.name = name;  
// this.age = age;  
 super(name,age);  
 this.major = major;  
 }

-   我们可以在子类的构造器中显式的使用 `super(形参列表)` 的方式，调用父类中指定的构造器
    
-   `super(形参列表)` 的使用，必须声明在子类构造器的首行
    
-   `this(形参列表)`构造器必须声明在首行；所以这两个构造器只能二选一，不能同时使用；且子类中也只能声明一个 `super`(形参列表) 或者 `this(形参列表)`
    
-   在构造器首行，没有显式的声明 `super()/this()`，则默认调用的是父类中的空参构造器
    
    -   如果父类没有空参构造器，则必须显式调用 `super(形参列表)` 构造器，否则报错
        
    -   并且，Java系统提供的默认空参构造器也会自动调用父类的空参构造器；因此，如果父类没有提供空参构造器，且子类没有自己定义构造器，就会发生错误。
        
    -   Implicit super construcotr Circle() is undefinedd. Must explicitily invoke antoher constructor 
        
    -   在类的多个构造器中，至少有一个类的构造器使用了 `super(形参列表)` 调用父类的构造器
        

### 子类对象实例化过程

#### 结果

-   当子类继承父类以后，子类就获取了父类中声明的属性和方法
    
-   创建的子类对象就在堆空间中加载了所有父类的属性（包括直接和间接父类）
    

#### 过程

-   我们通过子类的构造器创建子类对象
    
-   在子类构造器中，直接或间接的（可能从这个this调用到另一个this，但最后这些this指向一个首行为super的构造器）调用父类的构造器；父类直接或间接的调用其父类的构造器
    
-   直到调用到`java.lang.Object`的空参构造器位置
    

因此，我们最后创建出的子类会加载出父类的 `属性`， 子类才会有父类中的结构

#### 注意

-   虽然调用了多次构造器，但是最后只是造出一个子类对象。调用父类构造器不等于创建新对象 – 对外暴露的只是创建的子类对象的地址值。